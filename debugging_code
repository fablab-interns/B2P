#include <Bounce2.h>

// Motor control pins
#define IN1 7
#define IN2 6
#define ENA 9

// Encoder pins
#define ENCODER_C1 2
#define ENCODER_C2 3

// Button pins
#define BUTTON_DECREASE_BACKWARD_PIN 4
#define BUTTON_DECREMENT_PIN 10
#define BUTTON_INCREMENT_PIN 11
#define BUTTON_TOGGLE_PIN 12

// Variables
volatile long encoderCount = 0;
const int CPR = 28; // Counts per revolution (7 PPR * 4 quadrature steps)
const int incrementSteps = 1 * CPR;
const int motorSpeed = 150;
bool motorRunning = false;
long targetSteps = 0;

// Motor movement tracking
unsigned long lastEncoderUpdate = 0;
const int updateInterval = 10;

// Button instances
Bounce decreaseBackwardButton = Bounce();
Bounce incrementButton = Bounce();
Bounce decrementButton = Bounce();
Bounce toggleButton = Bounce();

void setup() {
    // Motor pins
    pinMode(IN1, OUTPUT);
    pinMode(IN2, OUTPUT);
    pinMode(ENA, OUTPUT);

    // Encoder pins
    pinMode(ENCODER_C1, INPUT);
    pinMode(ENCODER_C2, INPUT);

    // Button pins
    pinMode(BUTTON_DECREASE_BACKWARD_PIN, INPUT_PULLUP);
    pinMode(BUTTON_INCREMENT_PIN, INPUT_PULLUP);
    pinMode(BUTTON_DECREMENT_PIN, INPUT_PULLUP);
    pinMode(BUTTON_TOGGLE_PIN, INPUT_PULLUP);

    // Initialize buttons with increased debounce interval
    decreaseBackwardButton.attach(BUTTON_DECREASE_BACKWARD_PIN);
    decreaseBackwardButton.interval(50);

    incrementButton.attach(BUTTON_INCREMENT_PIN);
    incrementButton.interval(50);

    decrementButton.attach(BUTTON_DECREMENT_PIN);
    decrementButton.interval(50);

    toggleButton.attach(BUTTON_TOGGLE_PIN);
    toggleButton.interval(50);

    // Ensure motor is stopped initially
    analogWrite(ENA, 0);
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);

    // Attach encoder interrupt
    attachInterrupt(digitalPinToInterrupt(ENCODER_C1), readEncoder, CHANGE);

    // Start serial communication
    Serial.begin(115200);
}

void loop() {
    // Update button states
    decreaseBackwardButton.update();
    incrementButton.update();
    decrementButton.update();
    toggleButton.update();

    updateMotorMovement(); // Continuously check motor state

    // Increment button logic
    if (incrementButton.fell() && !motorRunning) {
        Serial.println("Increment Button Pressed");
        targetSteps += incrementSteps;
        Serial.print("Target Steps: ");
        Serial.println(targetSteps);
        executeMotorMovement();
    }

    // Decrement button logic
    if (decrementButton.fell() && !motorRunning) {
        Serial.println("Decrement Button Pressed");
        if (targetSteps >= incrementSteps) {
            targetSteps -= incrementSteps;
            executeMotorMovement();
        } else {
            Serial.println("Cannot Decrease Below Zero Rotations");
        }
    }

    // Toggle button logic
    if (toggleButton.fell()) {
        if (motorRunning) {
            stopMotor();
            Serial.println("Motor Stopped via Toggle");
        } else if (targetSteps > 0) {
            executeMotorMovement();
        } else {
            Serial.println("No Rotations Set (Target = 0)");
        }
    }

    // Decrease backward button logic
    if (decreaseBackwardButton.read() == LOW) {
        if (!motorRunning) {
            Serial.println("Decrease Backward Button Pressed - Moving Motor Backward");
            moveBackwardsContinuous();
        }
    } else {
        if (motorRunning) {
            stopMotor();
            Serial.println("Motor Stopped after Button Released");
        }
    }
}

// Non-blocking motor movement execution
void executeMotorMovement() {
    encoderCount = 0;
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
    analogWrite(ENA, motorSpeed);
    motorRunning = true;
}

// Function to continuously update motor movement
void updateMotorMovement() {
    if (motorRunning && encoderCount >= targetSteps) {
        stopMotor();
        Serial.println("Motor Stopped after Target Rotations");
    }

    // Print encoder count periodically
    if (millis() - lastEncoderUpdate > updateInterval) {
        lastEncoderUpdate = millis();
        Serial.print("Encoder Count: ");
        Serial.println(encoderCount);
    }
}

// Function to move the motor backward continuously
void moveBackwardsContinuous() {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    analogWrite(ENA, motorSpeed);
    motorRunning = true;
}

// Function to stop the motor
void stopMotor() {
    analogWrite(ENA, 0);
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    motorRunning = false;
}

// Encoder interrupt function with noise filtering
void readEncoder() {
    static unsigned long lastInterruptTime = 0;
    unsigned long interruptTime = millis();
    if (interruptTime - lastInterruptTime > 5) { // Noise filter
        static int lastState = LOW;
        int stateC1 = digitalRead(ENCODER_C1);
        int stateC2 = digitalRead(ENCODER_C2);

        if (stateC1 != lastState) {
            if (stateC1 == stateC2) {
                encoderCount++;
            } else {
                encoderCount--;
            }
            Serial.print("Interrupt: Encoder Count = ");
            Serial.println(encoderCount);
        }
        lastState = stateC1;
    }
    lastInterruptTime = interruptTime;
}
