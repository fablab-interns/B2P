#include <Bounce2.h>

// Motor control pins for ESP32
#define IN1 16  // Adjust according to your ESP32 pin layout
#define IN2 17
#define ENA 5   // ESP32 supports PWM on many pins

// Encoder pins
#define ENCODER_C1 34  // Must be GPIO34-39 for input-only pins on ESP32
#define ENCODER_C2 35

// Button pins
#define BUTTON_DECREASE_BACKWARD_PIN 4
#define BUTTON_DECREMENT_PIN 18
#define BUTTON_INCREMENT_PIN 19
#define BUTTON_TOGGLE_PIN 21

// PWM settings for ESP32
#define PWM_CHANNEL 0
#define PWM_FREQUENCY 5000
#define PWM_RESOLUTION 8  // 8-bit resolution (0-255)

// Variables
int fixedForwardSteps = 380;  
volatile long encoderCount = 0;
const int CPR = 28;             
const int incrementSteps = 1 * CPR;
const int motorSpeed = 150;
bool motorRunning = false;
long targetSteps = 0;

// Button instances
Bounce decreaseBackwardButton = Bounce();
Bounce incrementButton = Bounce();
Bounce decrementButton = Bounce();
Bounce toggleButton = Bounce();

void setup() {
  // Motor control pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENA, OUTPUT);

  // Initialize PWM on ESP32
  ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
  ledcAttachPin(ENA, PWM_CHANNEL);

  // Encoder pins
  pinMode(ENCODER_C1, INPUT);
  pinMode(ENCODER_C2, INPUT);

  // Button pins
  pinMode(BUTTON_DECREASE_BACKWARD_PIN, INPUT_PULLUP);
  pinMode(BUTTON_INCREMENT_PIN, INPUT_PULLUP);
  pinMode(BUTTON_DECREMENT_PIN, INPUT_PULLUP);
  pinMode(BUTTON_TOGGLE_PIN, INPUT_PULLUP);

  // Initialize the Bounce objects
  decreaseBackwardButton.attach(BUTTON_DECREASE_BACKWARD_PIN);
  decreaseBackwardButton.interval(50);

  incrementButton.attach(BUTTON_INCREMENT_PIN);
  incrementButton.interval(50);

  decrementButton.attach(BUTTON_DECREMENT_PIN);
  decrementButton.interval(50);

  toggleButton.attach(BUTTON_TOGGLE_PIN);
  toggleButton.interval(50);

  // Initially ensure motor is stopped
  ledcWrite(PWM_CHANNEL, 0);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);

  // Attach encoder interrupt
  attachInterrupt(digitalPinToInterrupt(ENCODER_C1), readEncoder, CHANGE);

  // Start serial communication
  Serial.begin(115200);
}

void loop() {
  decreaseBackwardButton.update();
  incrementButton.update();
  decrementButton.update();
  toggleButton.update();

  if (incrementButton.fell() && !motorRunning) {
    Serial.println("Increment Button Pressed");
    targetSteps += incrementSteps;
    Serial.println("Steps: " + String(targetSteps));
    executeMotorMovement();
  }

  if (decrementButton.fell() && !motorRunning) {
    Serial.println("Decrement Button Pressed");
    if (targetSteps >= incrementSteps) {
      targetSteps -= incrementSteps;
      if (targetSteps > 0) {
        executeMotorMovement();
      } else {
        Serial.println("No Rotations Set (Target = 0)");
      }
    } else {
      Serial.println("Cannot Decrease Below Zero Rotations");
    }
  }

  if (toggleButton.fell()) {
    if (!motorRunning) {
      targetSteps = fixedForwardSteps;
      Serial.println("Toggle Button Pressed: Moving Forward for Fixed Steps");
      executeMotorMovement();
    } else {
      stopMotor();
      Serial.println("Motor Stopped via Toggle");
    }
  }

  if (decreaseBackwardButton.read() == LOW) {
    if (!motorRunning) {
      Serial.println("Decrease Backward Button Pressed - Moving Motor Backward");
      moveBackwardsContinuous();
    }
  } else {
    if (motorRunning) {
      stopMotor();
      Serial.println("Motor Stopped after Button Released");
    }
  }
}

void executeMotorMovement() {
  encoderCount = 0;
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  ledcWrite(PWM_CHANNEL, motorSpeed);
  motorRunning = true;

  while (encoderCount < targetSteps) {
    Serial.print("Encoder Count: ");
    Serial.println(encoderCount);
    delay(10);
  }

  stopMotor();
  Serial.println("Motor Stopped after Target Rotations");
}

void moveBackwardsContinuous() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  ledcWrite(PWM_CHANNEL, motorSpeed);
  motorRunning = true;
  Serial.print("Reversing - Encoder Count: ");
  Serial.println(encoderCount);
  delay(10);
}

void stopMotor() {
  ledcWrite(PWM_CHANNEL, 0);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  motorRunning = false;
}

void readEncoder() {
  static int lastState = LOW;
  int stateC1 = digitalRead(ENCODER_C1);
  int stateC2 = digitalRead(ENCODER_C2);

  if (stateC1 != lastState) {
    if (stateC1 == stateC2) {
      encoderCount++;
    } else {
      encoderCount--;
    }
    Serial.print("Interrupt: Encoder Count = ");
    Serial.println(encoderCount);
  }
  lastState = stateC1;
}
