#define MotFwd  19  // Motor Forward pin
#define MotRev  21  // Motor Reverse pin

#define ButtonInc  32  // Increment button pin
#define ButtonDec  33  // Decrement button pin

int lastButtonIncState = HIGH;  // Previous state of increment button
int lastButtonDecState = HIGH;  // Previous state of decrement button

unsigned long lastDebounceTimeInc = 0;  // Last debounce time for increment button
unsigned long lastDebounceTimeDec = 0;  // Last debounce time for decrement button
unsigned long debounceDelay = 50;  // Debounce delay (in milliseconds)

void setup() {
  pinMode(MotFwd, OUTPUT); 
  pinMode(MotRev, OUTPUT); 
  Serial.begin(9600); // Initialize serial communication

  pinMode(ButtonInc, INPUT_PULLUP);  // Set increment button pin as input with pull-up resistor
  pinMode(ButtonDec, INPUT_PULLUP);  // Set decrement button pin as input with pull-up resistor

  // Initially, motor should be off
  digitalWrite(MotFwd, LOW);
  digitalWrite(MotRev, LOW);
}

void loop() {
  // Read the state of the increment button
  int readingInc = digitalRead(ButtonInc);

  // Check if the increment button has been pressed (LOW because of INPUT_PULLUP)
  if (readingInc == LOW && lastButtonIncState == HIGH && (millis() - lastDebounceTimeInc) > debounceDelay) {
    moveForward();  // Move forward for a certain amount of time
    lastDebounceTimeInc = millis();  // Record the time of the press
  }

  // Read the state of the decrement button
  int readingDec = digitalRead(ButtonDec);

  // Check if the decrement button has been pressed (LOW because of INPUT_PULLUP)
  if (readingDec == LOW && lastButtonDecState == HIGH && (millis() - lastDebounceTimeDec) > debounceDelay) {
    moveBackward();  // Move backward for a certain amount of time
    lastDebounceTimeDec = millis();  // Record the time of the press
  }

  // Store the current button states for the next loop iteration
  lastButtonIncState = readingInc;
  lastButtonDecState = readingDec;

  // Print motor status for debugging
  Serial.print("Motor is: ");
  if (digitalRead(MotFwd) == HIGH) {
    Serial.println("Forward");
  } else if (digitalRead(MotRev) == HIGH) {
    Serial.println("Reverse");
  } else {
    Serial.println("Stopped");
  }

  delay(100); // Small delay for stability
}

// Move motor forward for a set time (adjust the time to control distance)
void moveForward() {
  Serial.println("Moving Forward");
  digitalWrite(MotFwd, HIGH);  // Turn motor forward
  digitalWrite(MotRev, LOW);   // Ensure reverse is off

  delay(1000);  // Move forward for 1 second (adjust this as needed)
  
  digitalWrite(MotFwd, LOW);   // Stop the motor
  Serial.println("Motor Stopped after Moving Forward");
}

// Move motor backward for a set time (adjust the time to control distance)
void moveBackward() {
  Serial.println("Moving Backward");
  digitalWrite(MotFwd, LOW);   // Ensure forward is off
  digitalWrite(MotRev, HIGH);  // Turn motor in reverse

  delay(1000);  // Move backward for 1 second (adjust this as needed)
  
  digitalWrite(MotRev, LOW);   // Stop the motor
  Serial.println("Motor Stopped after Moving Backward");
}





// ---------------------------------------------------------

#define MotFwd  19  // Motor Forward pin
#define MotRev  21  // Motor Reverse pin

#define ButtonInc  32  // Increment button pin
#define ButtonDec  33  // Decrement button pin

int encoderPin1 = 18; // Encoder Output 'A' (connected to interrupt pin)
int encoderPin2 = 5;  // Encoder Output 'B' (connected to interrupt pin)

volatile int lastEncoded = 0; // Stores previous state of encoder
volatile long encoderValue = 0; // Raw encoder value (counts pulses)

unsigned long lastDebounceTimeInc = 0;  // Last debounce time for increment button
unsigned long lastDebounceTimeDec = 0;  // Last debounce time for decrement button
unsigned long debounceDelay = 50;  // Debounce delay (in milliseconds)

int motorSpeedRPM = 60;  // Motor speed in RPM (change this value to set desired speed)
int peakCountPerRevolution = 1000; // Number of encoder pulses per revolution
unsigned long timePerPeak;  // Time per peak in microseconds

void setup() {
  pinMode(MotFwd, OUTPUT); 
  pinMode(MotRev, OUTPUT); 
  Serial.begin(9600); // Initialize serial communication

  pinMode(ButtonInc, INPUT_PULLUP);  // Set increment button pin as input with pull-up resistor
  pinMode(ButtonDec, INPUT_PULLUP);  // Set decrement button pin as input with pull-up resistor

  // Initially, motor should be off
  digitalWrite(MotFwd, LOW);
  digitalWrite(MotRev, LOW);

  // Calculate time per peak based on the desired RPM
  timePerPeak = (60 * 1000000) / (motorSpeedRPM * peakCountPerRevolution);
  Serial.print("Time per peak: ");
  Serial.println(timePerPeak);  // Print the time per peak to the Serial Monitor for debugging
}

void loop() {
  // Read the state of the increment button
  int readingInc = digitalRead(ButtonInc);

  // Check if the increment button has been pressed (LOW because of INPUT_PULLUP)
  if (readingInc == LOW && (millis() - lastDebounceTimeInc) > debounceDelay) {
    motorSpeedRPM += 10;  // Increase speed by 10 RPM
    timePerPeak = (60 * 1000000) / (motorSpeedRPM * peakCountPerRevolution);
    lastDebounceTimeInc = millis();  // Record the time of the press
    Serial.print("Motor speed increased to: ");
    Serial.println(motorSpeedRPM);
  }

  // Read the state of the decrement button
  int readingDec = digitalRead(ButtonDec);

  // Check if the decrement button has been pressed (LOW because of INPUT_PULLUP)
  if (readingDec == LOW && (millis() - lastDebounceTimeDec) > debounceDelay) {
    motorSpeedRPM -= 10;  // Decrease speed by 10 RPM
    if (motorSpeedRPM < 0) motorSpeedRPM = 0;  // Prevent going below 0 RPM
    timePerPeak = (60 * 1000000) / (motorSpeedRPM * peakCountPerRevolution);
    lastDebounceTimeDec = millis();  // Record the time of the press
    Serial.print("Motor speed decreased to: ");
    Serial.println(motorSpeedRPM);
  }

  // Control the motor speed based on RPM
  moveMotorAtSpeed();

  delay(100); // Small delay for stability
}

// Move motor at the calculated speed
void moveMotorAtSpeed() {
  // Turn motor forward
  digitalWrite(MotFwd, HIGH);  
  digitalWrite(MotRev, LOW);   

  // Wait for the calculated time per peak to control the speed (RPM)
  delayMicroseconds(timePerPeak);  // Delay between each peak to control speed

  // Update encoder value (simulate a pulse from the encoder)
  encoderValue++;

  // Stop motor after a full revolution (1000 peaks)
  if (encoderValue >= peakCountPerRevolution) {
    digitalWrite(MotFwd, LOW);  // Stop motor
    encoderValue = 0;  // Reset encoder value for next revolution
    Serial.println("Motor stopped after one full revolution");
  }
}





// ----------------------------------------------------------------------------
#define MotFwd  19  // Motor Forward pin
#define MotRev  21  // Motor Reverse pin

#define ButtonInc  32  // Increment button pin
#define ButtonDec  33  // Decrement button pin
#define ButtonToggle  34  // Toggle button pin
#define ButtonRev  35  // Reverse button pin

int encoderPin1 = 18; // Encoder Output 'A' (connected to interrupt pin)
int encoderPin2 = 5;  // Encoder Output 'B' (connected to interrupt pin)

volatile long encoderValue = 0; // Raw encoder value (counts pulses)

unsigned long lastDebounceTimeInc = 0;  // Last debounce time for increment button
unsigned long lastDebounceTimeDec = 0;  // Last debounce time for decrement button
unsigned long lastDebounceTimeToggle = 0;  // Last debounce time for toggle button
unsigned long lastDebounceTimeRev = 0;  // Last debounce time for reverse button
unsigned long debounceDelay = 50;  // Debounce delay (in milliseconds)

int rotations = 5;  // Default number of rotations
int lastRotations = 0;  // Store last number of rotations

int peakCountPerRevolution = 1000;  // Number of encoder pulses per revolution
bool motorRunning = false;  // Track if the motor is running

void setup() {
  pinMode(MotFwd, OUTPUT); 
  pinMode(MotRev, OUTPUT); 
  Serial.begin(9600); // Initialize serial communication

  pinMode(ButtonInc, INPUT_PULLUP);  // Set increment button pin as input with pull-up resistor
  pinMode(ButtonDec, INPUT_PULLUP);  // Set decrement button pin as input with pull-up resistor
  pinMode(ButtonToggle, INPUT_PULLUP);  // Set toggle button pin as input with pull-up resistor
  pinMode(ButtonRev, INPUT_PULLUP);  // Set reverse button pin as input with pull-up resistor

  // Initially, motor should be off
  digitalWrite(MotFwd, LOW);
  digitalWrite(MotRev, LOW);
}

void loop() {
  // Read the state of the increment button
  int readingInc = digitalRead(ButtonInc);
  if (readingInc == LOW && (millis() - lastDebounceTimeInc) > debounceDelay) {
    rotations++;  // Increase the number of rotations
    lastDebounceTimeInc = millis();  // Record the time of the press
    Serial.print("Number of rotations increased to: ");
    Serial.println(rotations);
  }

  // Read the state of the decrement button
  int readingDec = digitalRead(ButtonDec);
  if (readingDec == LOW && (millis() - lastDebounceTimeDec) > debounceDelay) {
    rotations--;  // Decrease the number of rotations
    if (rotations < 1) rotations = 1;  // Prevent going below 1 rotation
    lastDebounceTimeDec = millis();  // Record the time of the press
    Serial.print("Number of rotations decreased to: ");
    Serial.println(rotations);
  }

  // Read the state of the toggle button
  int readingToggle = digitalRead(ButtonToggle);
  if (readingToggle == LOW && (millis() - lastDebounceTimeToggle) > debounceDelay) {
    lastRotations = rotations;  // Store last rotation count
    Serial.print("Toggled, last rotations set to: ");
    Serial.println(lastRotations);
    lastDebounceTimeToggle = millis();  // Record the time of the press
  }

  // Read the state of the reverse button
  int readingRev = digitalRead(ButtonRev);
  if (readingRev == LOW && (millis() - lastDebounceTimeRev) > debounceDelay) {
    moveBackward();  // Move backward as long as button is pressed
    lastDebounceTimeRev = millis();  // Record the time of the press
  }

  // Control the motor to move for the desired number of rotations
  if (!motorRunning) {
    moveMotorAtRotations(rotations);
  }

  delay(100); // Small delay for stability
}

// Move motor forward for a set number of rotations
void moveMotorAtRotations(int rotationsToMove) {
  long targetEncoderValue = encoderValue + rotationsToMove * peakCountPerRevolution;

  motorRunning = true;  // Set motor running state to true
  digitalWrite(MotFwd, HIGH);  
  digitalWrite(MotRev, LOW);   

  // Keep moving the motor until we reach the target rotations
  while (encoderValue < targetEncoderValue) {
    // Wait until the target rotations are reached
  }

  // Stop the motor after completing the desired rotations
  digitalWrite(MotFwd, LOW);  // Stop motor
  encoderValue = 0; // Reset encoder value for the next set of rotations
  motorRunning = false;  // Reset motor running state
  Serial.print("Motor stopped after ");
  Serial.print(rotationsToMove);
  Serial.println(" rotations");
}

// Move motor backward (as long as the reverse button is pressed)
void moveBackward() {
  motorRunning = true;  // Set motor running state to true
  digitalWrite(MotFwd, LOW);   // Ensure forward is off
  digitalWrite(MotRev, HIGH);  // Turn motor in reverse

  // Keep moving in reverse as long as button is pressed
  while (digitalRead(ButtonRev) == LOW) {
    // Move motor backward
  }

  // Stop motor when button is released
  digitalWrite(MotRev, LOW);   // Stop motor
  motorRunning = false;  // Reset motor running state
  Serial.println("Motor stopped after moving backward");
}
